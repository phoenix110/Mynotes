##
API对象是Kubernetes集群中的管理操作单元。Kubernetes集群系统每支持一项新功能，引入
一项新技术，一定会新引入对应的API对象，支持对该功能的管理操作。例如副本集Replica
Set对应的API对象是RS。
每个API对象都有3大类属性：元数据metadata、规范spec和状态status。元数据是用来标识
API对象的，每个对象都至少有3个元数据：namespace，name和uid；除此以外还有各种各
样的标签labels用来标识和匹配不同的对象，例如用户可以用标签env来标识区分不同的服务
部署环境，分别用env=dev、env=testing、env=production来标识开发、测试、生产的不同服
务。规范描述了用户期望Kubernetes集群中的分布式系统达到的理想状态（ Desired
State） ，例如用户可以通过复制控制器Replication Controller设置期望的Pod副本数为3；
status描述了系统实际当前达到的状态（ Status） ，例如系统当前实际的Pod副本数为2；那么
复制控制器当前的程序逻辑就是自动启动新的Pod，争取达到副本数为3。
# Pod
Kubernetes有很多技术概念，同时对应很多API对象，最重要的也是最基础的是Pod。Pod是
在Kubernetes集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理
念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这
种简单高效的方式组合完成服务。Pod对多容器的支持是K8最基础的设计理念。比如你运行
一个操作系统发行版的软件仓库，一个Nginx容器用来发布软件，另一个容器专门用来从源仓
库做同步，这两个容器的镜像不太可能是一个团队开发的，但是他们一块儿工作才能提供一
个微服务；这种情况下，不同的团队各自开发构建自己的容器镜像，在部署的时候组合成一
个微服务对外提供服务。
Pod是Kubernetes集群中所有业务类型的基础，可以看作运行在K8集群中的小机器人，不同
类型的业务就需要不同类型的小机器人去执行。目前Kubernetes中的业务主要可以分为长期
伺服型（ long-running） 、批处理型（ batch） 、节点后台支撑型（ node-daemon） 和有状态
应用型（ stateful application） ；分别对应的小机器人控制器为Deployment、Job、
DaemonSet和StatefulSet
# 副本控制器（ Replication Controller，RC）
RC是Kubernetes集群中最早的保证Pod高可用的API对象。通过监控运行中的Pod来保证集群
中运行指定数目的Pod副本。指定的数目可以是多个也可以是1个；少于指定数目，RC就会启
动运行新的Pod副本；多于指定数目，RC就会杀死多余的Pod副本。即使在指定数目为1的情
况下，通过RC运行Pod也比直接运行Pod更明智，因为RC也可以发挥它高可用的能力，保证
永远有1个Pod在运行。RC是Kubernetes较早期的技术概念，只适用于长期伺服型的业务类
型，比如控制小机器人提供高可用的Web服务。
# 副本集（ Replica Set，RS）
RS是新一代RC，提供同样的高可用能力，区别主要在于RS后来居上，能支持更多种类的匹
配模式。副本集对象一般不单独使用，而是作为Deployment的理想状态参数使用。
# 部署（ Deployment）
部署表示用户对Kubernetes集群的一次更新操作。部署是一个比RS应用模式更广的API对
象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。滚动升级
一个服务，实际是创建一个新的RS，然后逐渐将新RS中副本数增加到理想状态，将旧RS中
的副本数减小到0的复合操作；这样一个复合操作用一个RS是不太好描述的，所以用一个更
通用的Deployment来描述。以Kubernetes的发展方向，未来对所有长期伺服型的的业务的管
理，都会通过Deployment来管理。
# 服务（ Service）
RC、RS和Deployment只是保证了支撑服务的微服务Pod的数量，但是没有解决如何访问这
些服务的问题。一个Pod只是一个运行服务的实例，随时可能在一个节点上停止，在另一个节
点以一个新的IP启动一个新的Pod，因此不能以确定的IP和端口号提供服务。要稳定地提供服
务需要服务发现和负载均衡能力。服务发现完成的工作，是针对客户端访问的服务，找到对
应的的后端服务实例。在K8集群中，客户端需要访问的服务就是Service对象。每个Service会
对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。在Kubernetes集群中
微服务的负载均衡是由Kube-proxy实现的。Kube-proxy是Kubernetes集群内部的负载均衡
器。它是一个分布式代理服务器，在Kubernetes的每个节点上都有一个；这一设计体现了它
的伸缩性优势，需要访问服务的节点越多，提供负载均衡能力的Kube-proxy就越多，高可用
节点也随之增多。与之相比，我们平时在服务器端做个反向代理做负载均衡，还要进一步解
决反向代理的负载均衡和高可用问题。
# 任务（ Job）
# 后台支撑服务集（ DaemonSet）
长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的Pod，有些
节点上又没有这类Pod运行；而后台支撑型服务的核心关注点在Kubernetes集群中的节点（ 物
理机或虚拟机） ，要保证每个节点上都有一个此类Pod运行。节点可能是所有集群节点也可能
是通过nodeSelector选定的一些特定节点。典型的后台支撑型服务包括，存储，日志和监控等
在每个节点上支持Kubernetes集群运行的服务。
# 有状态服务集（ StatefulSet）
# 集群联邦（ Federation）
# 存储卷（ Volume）
Kubernetes集群中的存储卷跟Docker的存储卷有些类似，只不过Docker的存储卷作用范围为
一个容器，而Kubernetes的存储卷的生命周期和作用范围是一个Pod。每个Pod中声明的存储
卷由Pod中的所有容器共享。Kubernetes支持非常多的存储卷类型，特别的，支持多种公有云
平台的存储，包括AWS，Google和Azure云；支持多种分布式存储包括GlusterFS和Ceph；
也支持较容易使用的主机本地目录emptyDir, hostPath和NFS。Kubernetes还支持使用
Persistent Volume Claim即PVC这种逻辑存储，使用这种存储，使得存储的使用者可以忽略
后台的实际存储技术（ 例如AWS，Google或GlusterFS和Ceph） ，而将有关存储实际技术的
配置交给存储管理员通过Persistent Volume来配置。
# 持久存储卷（ Persistent Volume，PV） 和持久存储卷声明
#（ Persistent Volume Claim，PVC）
# 节点（ Node）
# 密钥对象（ Secret）
Secret是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。使用Secret的好处是可
以避免把敏感信息明文写在配置文件里。
# 用户帐户（ User Account） 和服务帐户（ Service Account）
顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和Kubernetes集群中运行
的Pod提供账户标识。用户帐户和服务帐户的一个区别是作用范围；用户帐户对应的是人的身
份，人的身份与服务的namespace无关，所以用户账户是跨namespace的；而服务帐户对应
的是一个运行中程序的身份，与特定namespace是相关的。
# 命名空间（ Namespace）
命名空间为Kubernetes集群提供虚拟的隔离作用，Kubernetes集群初始有两个命名空间，分
别是默认命名空间default和系统命名空间kube-system，除此以外，管理员可以可以创建新的
命名空间满足需要。
# RBAC访问授权
RBAC主要是引入了角色（ Role） 和角色绑定（ RoleBinding） 的抽象概
念。在ABAC中，Kubernetes集群中的访问策略只能跟用户直接关联；而在RBAC中，访问策
略可以跟某个角色关联，具体的用户在跟一个或多个角色相关联。显然，RBAC像其他新功能
一样，每次引入新功能，都会引入新的API对象，从而引入新的概念抽象，而这一新的概念抽
象一定会使集群服务管理和使用更容易扩展和重用。
